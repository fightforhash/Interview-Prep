#include <iostream>
#include <vector>
using namespace std;

int inf = 999999;
vector<int> ready(5003);
vector<int> dp(5003, inf);
// dp[n] := n을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값

// 어떤 N을 못 만들 때, dp[N] = INF

// - dp[0] := 0을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[1] := 1을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[2] := 2을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[3] := 3을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[4] := 4을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[5] := 5을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[6] := 6을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[7] := 7을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[8] := 8을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// - dp[9] := 9을 3과 5로 조합할 때 사용한 3과 5의 총 개수의 최솟값
// .
// .
// .

// dp[n] = min(dp[n-3], dp[n-5]);

//           dp[n-3] + 1     
// n을 만들 때 (.....) + 3
//            =n-3

//           dp[n-5] + 1
// n을 만들 때 (.....) + 5
//            =n-5

// dp[n] = min(dp[n-3]+1, dp[n-5]+1)

// 15 = 3 + 3 + 3 + 3 + 3
// 15 = 5 + 5 + 5
// dp[15] = 3

// 15를 만들기 위한 최적의 방법은 5 + 5 + 5.

// 20 = (3 + 3 + 3 + 3 + 3) + 5
// 20 = (5 + 5 + 5) + 5
// dp[20] = 4

// dp[20] = 4

// dp[20] ?= dp[15] + 1

// 20 = (3 + 3 + 3 + 5 + 3) + 3

// dp[20] ?= dp[17] + 1

// dp[20] = min(dp[17] + 1, dp[15] + 1)

// 

// 2x + 3 = 3x + 1 + 2 - x
// 0 = 0

// dp[n] = min(dp[n-3]+1, dp[n-5]+1)

// dp[5] = min(dp[2]+1, dp[0]+1)
// dp[6] = min(dp[3]+1, dp[1]+1)
// dp[7] = min(dp[4]+1, dp[2]+1)
// dp[8] = min(dp[5]+1, dp[3]+1)
// dp[9] = min(dp[6]+1, dp[4]+1)
// .
// .
// .
// dp[20] = min(dp[17]+1, dp[15]+1)
// .
// .
// .
// .


// dp[-1] = 99999999999
// dp[-2] = 99999999999

int solve(int k){
    if (k < 0) return inf;
    if (k == 0) return 0;
    
    if (ready[k]) return dp[k];
    ready[k] = true;

    return dp[k] = min(solve(k-3)+2, solve(k-5)+5);
}

int main(){

    int n;
    cin >> n;

    if (solve(n) < inf){
        cout << solve(n);
    }else{
        cout << -1;
    }
}